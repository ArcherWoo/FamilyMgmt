# MCPæœåŠ¡é›†æˆæ–¹æ¡ˆ v2025.6

## ğŸ“‹ æ–‡æ¡£ä¿¡æ¯
- **æ–‡æ¡£ç±»å‹**: MCPæœåŠ¡é›†æˆæ–¹æ¡ˆ
- **ç‰ˆæœ¬**: v2025.6 (MCPå¼•æ“è¯¦ç»†è®¾è®¡)
- **æ›´æ–°æ—¥æœŸ**: 2025-06-28
- **æŠ€æœ¯æ¶æ„**: Model Context Protocol (MCP) v1.0
- **é€‚ç”¨èŒƒå›´**: å¤–éƒ¨æ•°æ®æºå’ŒæœåŠ¡é›†æˆ

## ğŸŒ MCPåè®®æ¦‚è¿°

### ä»€ä¹ˆæ˜¯MCPï¼Ÿ
Model Context Protocol (MCP) æ˜¯ç”±Anthropicä¸»å¯¼å¼€å‘çš„å¼€æºåè®®ï¼Œä¸“é—¨ç”¨äºAIæ¨¡å‹ä¸å¤–éƒ¨æ•°æ®æºå’Œå·¥å…·çš„æ ‡å‡†åŒ–è¿æ¥ã€‚

### MCPæ ¸å¿ƒä¼˜åŠ¿
- **æ ‡å‡†åŒ–æ¥å£**: ç»Ÿä¸€çš„æ•°æ®è·å–å’Œå·¥å…·è°ƒç”¨æ¥å£
- **å®‰å…¨å¯é **: å†…ç½®å®‰å…¨æœºåˆ¶å’Œé”™è¯¯å¤„ç†
- **æ˜“äºæ‰©å±•**: æ”¯æŒè‡ªå®šä¹‰å·¥å…·å’Œèµ„æº
- **ç¤¾åŒºæ”¯æŒ**: æ´»è·ƒçš„å¼€æºç¤¾åŒºå’Œä¸°å¯Œçš„ç”Ÿæ€

### MCP vs ä¼ ç»ŸAPI
| ç‰¹æ€§ | ä¼ ç»ŸAPI | MCPåè®® |
|------|---------|---------|
| æ ‡å‡†åŒ– | å„è‡ªå®šä¹‰ | ç»Ÿä¸€æ ‡å‡† |
| å®‰å…¨æ€§ | éœ€è‡ªè¡Œå®ç° | å†…ç½®å®‰å…¨æœºåˆ¶ |
| é”™è¯¯å¤„ç† | ä¸ç»Ÿä¸€ | æ ‡å‡†åŒ–é”™è¯¯å¤„ç† |
| å·¥å…·å‘ç° | æ‰‹åŠ¨é…ç½® | è‡ªåŠ¨å‘ç° |
| ç±»å‹å®‰å…¨ | å¼±ç±»å‹ | å¼ºç±»å‹å®šä¹‰ |

## ğŸ—ï¸ MCPæ¶æ„è®¾è®¡

### MCPæœåŠ¡æ¶æ„
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    ğŸŒ MCPæœåŠ¡æ³¨å†Œä¸­å¿ƒ                           â”‚
â”‚              MCP Server Registry + æœåŠ¡å‘ç°                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚  æœåŠ¡æ³¨å†Œ   â”‚  å¥åº·æ£€æŸ¥   â”‚  è´Ÿè½½å‡è¡¡   â”‚  ç‰ˆæœ¬ç®¡ç†       â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚
                              â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    ğŸ”Œ MCPå®¢æˆ·ç«¯å±‚                               â”‚
â”‚              ç»Ÿä¸€çš„MCPåè®®å®¢æˆ·ç«¯å’Œè¿æ¥ç®¡ç†                       â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚  è¿æ¥æ±      â”‚  é‡è¯•æœºåˆ¶   â”‚  ç¼“å­˜ç®¡ç†   â”‚  ç›‘æ§ç»Ÿè®¡       â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚
                â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                â–¼             â–¼             â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ğŸ¥— è¥å…»æ•°æ®åº“MCP â”‚ â”‚ ğŸŒ¤ï¸ å¤©æ°”æœåŠ¡MCP  â”‚ â”‚ ğŸ›’ è´­ç‰©å¹³å°MCP  â”‚
â”‚                 â”‚ â”‚                 â”‚ â”‚                 â”‚
â”‚ Tools:          â”‚ â”‚ Tools:          â”‚ â”‚ Tools:          â”‚
â”‚ - é£Ÿç‰©è¥å…»æŸ¥è¯¢   â”‚ â”‚ - å½“å‰å¤©æ°”      â”‚ â”‚ - å•†å“æœç´¢      â”‚
â”‚ - è¥å…»åˆ†æ      â”‚ â”‚ - å¤©æ°”é¢„æŠ¥      â”‚ â”‚ - ä»·æ ¼æ¯”è¾ƒ      â”‚
â”‚ - è†³é£Ÿå»ºè®®      â”‚ â”‚ - ç”Ÿæ´»æŒ‡æ•°      â”‚ â”‚ - åº“å­˜æŸ¥è¯¢      â”‚
â”‚                 â”‚ â”‚                 â”‚ â”‚                 â”‚
â”‚ Resources:      â”‚ â”‚ Resources:      â”‚ â”‚ Resources:      â”‚
â”‚ - é£Ÿç‰©æ•°æ®åº“    â”‚ â”‚ - æ°”è±¡æ•°æ®      â”‚ â”‚ - å•†å“ç›®å½•      â”‚
â”‚ - è¥å…»æ ‡å‡†      â”‚ â”‚ - å†å²å¤©æ°”      â”‚ â”‚ - ç”¨æˆ·åå¥½      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### MCPæœåŠ¡åˆ†ç±»

#### 1. æ•°æ®æœåŠ¡ç±»MCP
- **è¥å…»æ•°æ®åº“MCP**: USDAé£Ÿç‰©æ•°æ®åº“ã€ä¸­å›½é£Ÿç‰©æˆåˆ†è¡¨
- **å¥åº·æ•°æ®MCP**: ç”¨æˆ·å¥åº·æ¡£æ¡ˆã€è¿åŠ¨æ•°æ®ã€ä½“å¾ç›‘æµ‹
- **åœ°ç†ä½ç½®MCP**: åœ°ç†ç¼–ç ã€POIæŸ¥è¯¢ã€è·ç¦»è®¡ç®—
- **æ—¶å°šæ•°æ®MCP**: æœè£…æ­é…ã€æµè¡Œè¶‹åŠ¿ã€å“ç‰Œä¿¡æ¯

#### 2. å¤–éƒ¨APIç±»MCP
- **å¤©æ°”æœåŠ¡MCP**: å’Œé£å¤©æ°”ã€OpenWeatherMap
- **è´­ç‰©å¹³å°MCP**: æ·˜å®ã€äº¬ä¸œã€ç¾å›¢
- **åœ°å›¾æœåŠ¡MCP**: é«˜å¾·åœ°å›¾ã€ç™¾åº¦åœ°å›¾
- **ç¤¾äº¤åª’ä½“MCP**: å¾®ä¿¡ã€å¾®åšã€å°çº¢ä¹¦

#### 3. å·¥å…·æœåŠ¡ç±»MCP
- **å›¾åƒå¤„ç†MCP**: å›¾åƒè¯†åˆ«ã€å›¾åƒç”Ÿæˆã€å›¾åƒç¼–è¾‘
- **æ–‡æœ¬å¤„ç†MCP**: ç¿»è¯‘ã€æ‘˜è¦ã€æƒ…æ„Ÿåˆ†æ
- **è®¡ç®—æœåŠ¡MCP**: æ•°å­¦è®¡ç®—ã€ç»Ÿè®¡åˆ†æã€æ•°æ®å¯è§†åŒ–
- **é€šçŸ¥æœåŠ¡MCP**: é‚®ä»¶ã€çŸ­ä¿¡ã€æ¨é€é€šçŸ¥

## ğŸ”§ MCPæœåŠ¡å®ç°

### è¥å…»æ•°æ®åº“MCPå®ç°
```python
# nutrition_database_mcp.py
from mcp import Server, Tool, Resource
from typing import List, Dict, Any
import asyncio
import aiohttp

class NutritionDatabaseMCP(Server):
    def __init__(self):
        super().__init__(name="nutrition-database")
        self.usda_api_key = "your-usda-api-key"
        self.base_url = "https://api.nal.usda.gov/fdc/v1"
        
    @Tool(
        name="search_food",
        description="æœç´¢é£Ÿç‰©å¹¶è·å–åŸºæœ¬ä¿¡æ¯",
        parameters={
            "query": {"type": "string", "description": "é£Ÿç‰©åç§°"},
            "limit": {"type": "integer", "description": "è¿”å›ç»“æœæ•°é‡", "default": 10}
        }
    )
    async def search_food(self, query: str, limit: int = 10) -> List[Dict]:
        """æœç´¢é£Ÿç‰©"""
        async with aiohttp.ClientSession() as session:
            params = {
                "query": query,
                "dataType": ["Foundation", "SR Legacy"],
                "pageSize": limit,
                "api_key": self.usda_api_key
            }
            
            async with session.get(f"{self.base_url}/foods/search", params=params) as resp:
                data = await resp.json()
                
                foods = []
                for food in data.get("foods", []):
                    foods.append({
                        "fdc_id": food["fdcId"],
                        "description": food["description"],
                        "brand_owner": food.get("brandOwner"),
                        "data_type": food["dataType"]
                    })
                
                return foods
    
    @Tool(
        name="get_food_nutrition",
        description="è·å–é£Ÿç‰©è¯¦ç»†è¥å…»ä¿¡æ¯",
        parameters={
            "fdc_id": {"type": "integer", "description": "é£Ÿç‰©FDC ID"},
            "nutrients": {"type": "array", "description": "éœ€è¦çš„è¥å…»ç´ åˆ—è¡¨", "optional": True}
        }
    )
    async def get_food_nutrition(self, fdc_id: int, nutrients: List[str] = None) -> Dict:
        """è·å–é£Ÿç‰©è¥å…»ä¿¡æ¯"""
        async with aiohttp.ClientSession() as session:
            url = f"{self.base_url}/food/{fdc_id}"
            params = {"api_key": self.usda_api_key}
            
            async with session.get(url, params=params) as resp:
                data = await resp.json()
                
                nutrition_data = {
                    "fdc_id": data["fdcId"],
                    "description": data["description"],
                    "nutrients": {}
                }
                
                for nutrient in data.get("foodNutrients", []):
                    nutrient_name = nutrient["nutrient"]["name"]
                    nutrient_value = nutrient.get("amount", 0)
                    nutrient_unit = nutrient["nutrient"]["unitName"]
                    
                    if nutrients is None or nutrient_name in nutrients:
                        nutrition_data["nutrients"][nutrient_name] = {
                            "value": nutrient_value,
                            "unit": nutrient_unit
                        }
                
                return nutrition_data
    
    @Tool(
        name="analyze_meal_nutrition",
        description="åˆ†ææ•´é¤è¥å…»æˆåˆ†",
        parameters={
            "foods": {
                "type": "array",
                "description": "é£Ÿç‰©åˆ—è¡¨",
                "items": {
                    "type": "object",
                    "properties": {
                        "fdc_id": {"type": "integer"},
                        "amount": {"type": "number", "description": "é£Ÿç‰©é‡é‡(å…‹)"}
                    }
                }
            }
        }
    )
    async def analyze_meal_nutrition(self, foods: List[Dict]) -> Dict:
        """åˆ†ææ•´é¤è¥å…»"""
        total_nutrition = {
            "total_calories": 0,
            "total_protein": 0,
            "total_carbs": 0,
            "total_fat": 0,
            "detailed_nutrients": {}
        }
        
        for food_item in foods:
            fdc_id = food_item["fdc_id"]
            amount = food_item["amount"]  # å…‹
            
            # è·å–100gçš„è¥å…»ä¿¡æ¯
            nutrition = await self.get_food_nutrition(fdc_id)
            
            # æŒ‰å®é™…é‡é‡è®¡ç®—
            scale_factor = amount / 100
            
            for nutrient_name, nutrient_info in nutrition["nutrients"].items():
                scaled_value = nutrient_info["value"] * scale_factor
                
                if nutrient_name not in total_nutrition["detailed_nutrients"]:
                    total_nutrition["detailed_nutrients"][nutrient_name] = {
                        "value": 0,
                        "unit": nutrient_info["unit"]
                    }
                
                total_nutrition["detailed_nutrients"][nutrient_name]["value"] += scaled_value
                
                # è®¡ç®—ä¸»è¦è¥å…»ç´ 
                if "Energy" in nutrient_name:
                    total_nutrition["total_calories"] += scaled_value
                elif "Protein" in nutrient_name:
                    total_nutrition["total_protein"] += scaled_value
                elif "Carbohydrate" in nutrient_name:
                    total_nutrition["total_carbs"] += scaled_value
                elif "Total lipid" in nutrient_name:
                    total_nutrition["total_fat"] += scaled_value
        
        return total_nutrition
    
    @Resource(
        name="nutrition_standards",
        description="è¥å…»æ ‡å‡†å’Œæ¨èæ‘„å…¥é‡",
        uri="nutrition://standards"
    )
    async def get_nutrition_standards(self) -> Dict:
        """è·å–è¥å…»æ ‡å‡†"""
        return {
            "daily_recommendations": {
                "adult_male": {
                    "calories": 2500,
                    "protein": 56,  # å…‹
                    "carbs": 300,   # å…‹
                    "fat": 78       # å…‹
                },
                "adult_female": {
                    "calories": 2000,
                    "protein": 46,  # å…‹
                    "carbs": 225,   # å…‹
                    "fat": 65       # å…‹
                }
            },
            "nutrient_limits": {
                "sodium": 2300,     # æ¯«å…‹
                "sugar": 50,        # å…‹
                "saturated_fat": 20 # å…‹
            }
        }

# MCPæœåŠ¡å¯åŠ¨
async def main():
    server = NutritionDatabaseMCP()
    await server.run(host="0.0.0.0", port=3001)

if __name__ == "__main__":
    asyncio.run(main())
```

### å¤©æ°”æœåŠ¡MCPå®ç°
```python
# weather_service_mcp.py
from mcp import Server, Tool, Resource
from typing import Dict, List
import asyncio
import aiohttp

class WeatherServiceMCP(Server):
    def __init__(self):
        super().__init__(name="weather-service")
        self.qweather_key = "your-qweather-key"
        self.base_url = "https://devapi.qweather.com/v7"
        
    @Tool(
        name="get_current_weather",
        description="è·å–å½“å‰å¤©æ°”ä¿¡æ¯",
        parameters={
            "location": {"type": "string", "description": "åŸå¸‚åç§°æˆ–åæ ‡"},
            "lang": {"type": "string", "description": "è¯­è¨€", "default": "zh"}
        }
    )
    async def get_current_weather(self, location: str, lang: str = "zh") -> Dict:
        """è·å–å½“å‰å¤©æ°”"""
        # å…ˆè·å–ä½ç½®ID
        location_id = await self._get_location_id(location)
        
        async with aiohttp.ClientSession() as session:
            params = {
                "location": location_id,
                "key": self.qweather_key,
                "lang": lang
            }
            
            async with session.get(f"{self.base_url}/weather/now", params=params) as resp:
                data = await resp.json()
                
                if data["code"] == "200":
                    weather = data["now"]
                    return {
                        "location": location,
                        "temperature": weather["temp"],
                        "feels_like": weather["feelsLike"],
                        "condition": weather["text"],
                        "humidity": weather["humidity"],
                        "wind_speed": weather["windSpeed"],
                        "wind_direction": weather["windDir"],
                        "pressure": weather["pressure"],
                        "visibility": weather["vis"],
                        "update_time": data["updateTime"]
                    }
                else:
                    raise Exception(f"Weather API error: {data['code']}")
    
    @Tool(
        name="get_weather_forecast",
        description="è·å–å¤©æ°”é¢„æŠ¥",
        parameters={
            "location": {"type": "string", "description": "åŸå¸‚åç§°æˆ–åæ ‡"},
            "days": {"type": "integer", "description": "é¢„æŠ¥å¤©æ•°", "default": 3}
        }
    )
    async def get_weather_forecast(self, location: str, days: int = 3) -> List[Dict]:
        """è·å–å¤©æ°”é¢„æŠ¥"""
        location_id = await self._get_location_id(location)
        
        endpoint = "3d" if days <= 3 else "7d"
        
        async with aiohttp.ClientSession() as session:
            params = {
                "location": location_id,
                "key": self.qweather_key
            }
            
            async with session.get(f"{self.base_url}/weather/{endpoint}", params=params) as resp:
                data = await resp.json()
                
                if data["code"] == "200":
                    forecasts = []
                    for daily in data["daily"][:days]:
                        forecasts.append({
                            "date": daily["fxDate"],
                            "temp_max": daily["tempMax"],
                            "temp_min": daily["tempMin"],
                            "condition_day": daily["textDay"],
                            "condition_night": daily["textNight"],
                            "humidity": daily["humidity"],
                            "pressure": daily["pressure"],
                            "wind_speed": daily["windSpeedDay"],
                            "precipitation": daily.get("precip", "0")
                        })
                    return forecasts
                else:
                    raise Exception(f"Weather API error: {data['code']}")
    
    @Tool(
        name="get_lifestyle_indices",
        description="è·å–ç”Ÿæ´»æŒ‡æ•°",
        parameters={
            "location": {"type": "string", "description": "åŸå¸‚åç§°æˆ–åæ ‡"},
            "indices": {"type": "array", "description": "æŒ‡æ•°ç±»å‹åˆ—è¡¨", "optional": True}
        }
    )
    async def get_lifestyle_indices(self, location: str, indices: List[str] = None) -> Dict:
        """è·å–ç”Ÿæ´»æŒ‡æ•°"""
        location_id = await self._get_location_id(location)
        
        # é»˜è®¤è·å–æ‰€æœ‰æŒ‡æ•°
        if indices is None:
            indices = ["1", "2", "3", "5", "6", "8", "9"]  # ç©¿è¡£ã€æ´—è½¦ã€æ„Ÿå†’ã€è¿åŠ¨ã€æ—…æ¸¸ã€ç´«å¤–çº¿ã€èˆ’é€‚åº¦
        
        async with aiohttp.ClientSession() as session:
            params = {
                "location": location_id,
                "type": ",".join(indices),
                "key": self.qweather_key
            }
            
            async with session.get(f"{self.base_url}/indices/1d", params=params) as resp:
                data = await resp.json()
                
                if data["code"] == "200":
                    lifestyle_data = {}
                    for index in data["daily"]:
                        lifestyle_data[index["name"]] = {
                            "level": index["level"],
                            "category": index["category"],
                            "text": index["text"]
                        }
                    return lifestyle_data
                else:
                    raise Exception(f"Weather API error: {data['code']}")
    
    async def _get_location_id(self, location: str) -> str:
        """è·å–ä½ç½®ID"""
        async with aiohttp.ClientSession() as session:
            params = {
                "location": location,
                "key": self.qweather_key
            }
            
            async with session.get(f"{self.base_url}/city/lookup", params=params) as resp:
                data = await resp.json()
                
                if data["code"] == "200" and data["location"]:
                    return data["location"][0]["id"]
                else:
                    raise Exception(f"Location not found: {location}")

# MCPæœåŠ¡å¯åŠ¨
async def main():
    server = WeatherServiceMCP()
    await server.run(host="0.0.0.0", port=3002)

if __name__ == "__main__":
    asyncio.run(main())
```

## ğŸš€ MCPæœåŠ¡éƒ¨ç½²

### Dockeréƒ¨ç½²é…ç½®
```dockerfile
# Dockerfile for MCP services
FROM python:3.11-slim

WORKDIR /app

COPY requirements.txt .
RUN pip install -r requirements.txt

COPY . .

EXPOSE 3000

CMD ["python", "mcp_server.py"]
```

### Kuberneteséƒ¨ç½²
```yaml
# mcp-services-deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: nutrition-database-mcp
spec:
  replicas: 2
  selector:
    matchLabels:
      app: nutrition-database-mcp
  template:
    metadata:
      labels:
        app: nutrition-database-mcp
    spec:
      containers:
      - name: nutrition-db-mcp
        image: family-ai/nutrition-db-mcp:v1.0
        ports:
        - containerPort: 3001
        env:
        - name: USDA_API_KEY
          valueFrom:
            secretKeyRef:
              name: api-keys
              key: usda-api-key
---
apiVersion: v1
kind: Service
metadata:
  name: nutrition-database-mcp-service
spec:
  selector:
    app: nutrition-database-mcp
  ports:
  - port: 3001
    targetPort: 3001
  type: ClusterIP
```

## ğŸ“Š MCPæœåŠ¡ç›‘æ§

### æ€§èƒ½æŒ‡æ ‡
- **å“åº”æ—¶é—´**: ç›®æ ‡<2ç§’
- **æˆåŠŸç‡**: ç›®æ ‡>99%
- **å¹¶å‘å¤„ç†**: æ”¯æŒ100+å¹¶å‘è¯·æ±‚
- **ç¼“å­˜å‘½ä¸­ç‡**: ç›®æ ‡>80%

### ç›‘æ§é…ç½®
```yaml
# prometheus-mcp-config.yaml
- job_name: 'mcp-services'
  static_configs:
  - targets: 
    - 'nutrition-database-mcp:3001'
    - 'weather-service-mcp:3002'
    - 'shopping-platform-mcp:3003'
  metrics_path: '/metrics'
  scrape_interval: 30s
```

---

**ğŸ“… æ–‡æ¡£ç‰ˆæœ¬**: v2025.6  
**ğŸ”„ æœ€åæ›´æ–°**: 2025-06-28  
**ğŸŒ MCPåè®®**: Model Context Protocol v1.0  
**ğŸ¯ æœåŠ¡ç‰¹è‰²**: æ ‡å‡†åŒ–ã€å®‰å…¨å¯é ã€æ˜“äºæ‰©å±•

*åŸºäºMCPåè®®æ„å»ºçš„æ ‡å‡†åŒ–å¤–éƒ¨æœåŠ¡é›†æˆæ–¹æ¡ˆ* ğŸš€
